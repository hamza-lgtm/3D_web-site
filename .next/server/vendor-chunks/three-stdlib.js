"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/EventDispatcher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventDispatcher {\n  constructor() {\n    // not defined in @types/three\n    __publicField(this, \"_listeners\");\n  }\n  /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */\n  addEventListener(type, listener) {\n    if (this._listeners === void 0)\n      this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  /**\n      * Checks if listener is added to an event type.\n      * @param type The type of event to listen to.\n      * @param listener The function that gets called when the event is fired.\n      */\n  hasEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return false;\n    const listeners = this._listeners;\n    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  }\n  /**\n      * Removes a listener from an event type.\n      * @param type The type of the listener that gets removed.\n      * @param listener The listener function that gets removed.\n      */\n  removeEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== void 0) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  /**\n      * Fire an event type.\n      * @param event The event that gets fired.\n      */\n  dispatchEvent(event) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== void 0) {\n      event.target = this;\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\n\n//# sourceMappingURL=EventDispatcher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc25pcGVyLWFpLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9jb250cm9scy9FdmVudERpc3BhdGNoZXIuanM/NTZmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBFdmVudERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBub3QgZGVmaW5lZCBpbiBAdHlwZXMvdGhyZWVcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2xpc3RlbmVyc1wiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBpZiAobGlzdGVuZXJzW3R5cGVdID09PSB2b2lkIDApIHtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgIH1cbiAgICBpZiAobGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICAgICogQ2hlY2tzIGlmIGxpc3RlbmVyIGlzIGFkZGVkIHRvIGFuIGV2ZW50IHR5cGUuXG4gICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAgICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxuICAgICAgKi9cbiAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgcmV0dXJuIGxpc3RlbmVyc1t0eXBlXSAhPT0gdm9pZCAwICYmIGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLTE7XG4gIH1cbiAgLyoqXG4gICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmcm9tIGFuIGV2ZW50IHR5cGUuXG4gICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciB0aGF0IGdldHMgcmVtb3ZlZC5cbiAgICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IGdldHMgcmVtb3ZlZC5cbiAgICAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgaWYgKGxpc3RlbmVyQXJyYXkgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBsaXN0ZW5lckFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgICAgKiBGaXJlIGFuIGV2ZW50IHR5cGUuXG4gICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdGhhdCBnZXRzIGZpcmVkLlxuICAgICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1tldmVudC50eXBlXTtcbiAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdm9pZCAwKSB7XG4gICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgY29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgICBldmVudC50YXJnZXQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHtcbiAgRXZlbnREaXNwYXRjaGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnREaXNwYXRjaGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/OrbitControls.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapControls: () => (/* binding */ MapControls),\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher.js */ \"(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n\nconst _ray = new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity) => (offset % capacity + capacity) % capacity;\nclass OrbitControls extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    __publicField(this, \"object\");\n    __publicField(this, \"domElement\");\n    // Set to false to disable this control\n    __publicField(this, \"enabled\", true);\n    // \"target\" sets the location of focus, where the object orbits around\n    __publicField(this, \"target\", new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    __publicField(this, \"minDistance\", 0);\n    __publicField(this, \"maxDistance\", Infinity);\n    // How far you can zoom in and out ( OrthographicCamera only )\n    __publicField(this, \"minZoom\", 0);\n    __publicField(this, \"maxZoom\", Infinity);\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    __publicField(this, \"minPolarAngle\", 0);\n    // radians\n    __publicField(this, \"maxPolarAngle\", Math.PI);\n    // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n    __publicField(this, \"minAzimuthAngle\", -Infinity);\n    // radians\n    __publicField(this, \"maxAzimuthAngle\", Infinity);\n    // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"enableDamping\", false);\n    __publicField(this, \"dampingFactor\", 0.05);\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    __publicField(this, \"enableZoom\", true);\n    __publicField(this, \"zoomSpeed\", 1);\n    // Set to false to disable rotating\n    __publicField(this, \"enableRotate\", true);\n    __publicField(this, \"rotateSpeed\", 1);\n    // Set to false to disable panning\n    __publicField(this, \"enablePan\", true);\n    __publicField(this, \"panSpeed\", 1);\n    __publicField(this, \"screenSpacePanning\", true);\n    // if false, pan orthogonal to world-space direction camera.up\n    __publicField(this, \"keyPanSpeed\", 7);\n    // pixels moved per arrow key push\n    __publicField(this, \"zoomToCursor\", false);\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    __publicField(this, \"autoRotate\", false);\n    __publicField(this, \"autoRotateSpeed\", 2);\n    // 30 seconds per orbit when fps is 60\n    __publicField(this, \"reverseOrbit\", false);\n    // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n    __publicField(this, \"reverseHorizontalOrbit\", false);\n    // true if you want to reverse the horizontal orbit direction\n    __publicField(this, \"reverseVerticalOrbit\", false);\n    // true if you want to reverse the vertical orbit direction\n    // The four arrow keys\n    __publicField(this, \"keys\", { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" });\n    // Mouse buttons\n    __publicField(this, \"mouseButtons\", {\n      LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n      MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n      RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n    });\n    // Touch fingers\n    __publicField(this, \"touches\", { ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE, TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN });\n    __publicField(this, \"target0\");\n    __publicField(this, \"position0\");\n    __publicField(this, \"zoom0\");\n    // the target DOM element for key events\n    __publicField(this, \"_domElementKeyEvents\", null);\n    __publicField(this, \"getPolarAngle\");\n    __publicField(this, \"getAzimuthalAngle\");\n    __publicField(this, \"setPolarAngle\");\n    __publicField(this, \"setAzimuthalAngle\");\n    __publicField(this, \"getDistance\");\n    // Not used in most scenarios, however they can be useful for specific use cases\n    __publicField(this, \"getZoomScale\");\n    __publicField(this, \"listenToKeyEvents\");\n    __publicField(this, \"stopListenToKeyEvents\");\n    __publicField(this, \"saveState\");\n    __publicField(this, \"reset\");\n    __publicField(this, \"update\");\n    __publicField(this, \"connect\");\n    __publicField(this, \"dispose\");\n    // Dolly in programmatically\n    __publicField(this, \"dollyIn\");\n    // Dolly out programmatically\n    __publicField(this, \"dollyOut\");\n    // Get the current scale\n    __publicField(this, \"getScale\");\n    // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n    __publicField(this, \"setScale\");\n    this.object = object;\n    this.domElement = domElement;\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this.getPolarAngle = () => spherical.phi;\n    this.getAzimuthalAngle = () => spherical.theta;\n    this.setPolarAngle = (value) => {\n      let phi = moduloWrapAround(value, 2 * Math.PI);\n      let currentPhi = spherical.phi;\n      if (currentPhi < 0)\n        currentPhi += 2 * Math.PI;\n      if (phi < 0)\n        phi += 2 * Math.PI;\n      let phiDist = Math.abs(phi - currentPhi);\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI;\n        } else {\n          currentPhi += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi;\n      scope.update();\n    };\n    this.setAzimuthalAngle = (value) => {\n      let theta = moduloWrapAround(value, 2 * Math.PI);\n      let currentTheta = spherical.theta;\n      if (currentTheta < 0)\n        currentTheta += 2 * Math.PI;\n      if (theta < 0)\n        theta += 2 * Math.PI;\n      let thetaDist = Math.abs(theta - currentTheta);\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI;\n        } else {\n          currentTheta += 2 * Math.PI;\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta;\n      scope.update();\n    };\n    this.getDistance = () => scope.object.position.distanceTo(scope.target);\n    this.listenToKeyEvents = (domElement2) => {\n      domElement2.addEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = domElement2;\n    };\n    this.stopListenToKeyEvents = () => {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n    this.saveState = () => {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n    this.reset = () => {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(changeEvent);\n      scope.update();\n      state = STATE.NONE;\n    };\n    this.update = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const up = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n      const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, up);\n      const quatInverse = quat.clone().invert();\n      const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n      const twoPI = 2 * Math.PI;\n      return function update() {\n        const position = scope.object.position;\n        quat.setFromUnitVectors(object.up, up);\n        quatInverse.copy(quat).invert();\n        offset.copy(position).sub(scope.target);\n        offset.applyQuaternion(quat);\n        spherical.setFromVector3(offset);\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI)\n            min += twoPI;\n          else if (min > Math.PI)\n            min -= twoPI;\n          if (max < -Math.PI)\n            max += twoPI;\n          else if (max > Math.PI)\n            max -= twoPI;\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n          }\n        }\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n        spherical.makeSafe();\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n        if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n        offset.setFromSpherical(spherical);\n        offset.applyQuaternion(quatInverse);\n        position.copy(scope.target).add(offset);\n        if (!scope.object.matrixAutoUpdate)\n          scope.object.updateMatrix();\n        scope.object.lookAt(scope.target);\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n          panOffset.set(0, 0, 0);\n        }\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n            const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n            newRadius = offset.length();\n          } else {\n            console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n            scope.zoomToCursor = false;\n          }\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n            } else {\n              _ray.origin.copy(scope.object.position);\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1;\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n            scope.object.updateProjectionMatrix();\n          }\n        }\n        scale = 1;\n        performCursorZoom = false;\n        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n          scope.dispatchEvent(changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n        return false;\n      };\n    })();\n    this.connect = (domElement2) => {\n      scope.domElement = domElement2;\n      scope.domElement.style.touchAction = \"none\";\n      scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n      scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n      scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n      scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n    };\n    this.dispose = () => {\n      var _a, _b, _c, _d, _e, _f;\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = \"auto\";\n      }\n      (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n      (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n      (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n      (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n      (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n      (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n      }\n    };\n    const scope = this;\n    const changeEvent = { type: \"change\" };\n    const startEvent = { type: \"start\" };\n    const endEvent = { type: \"end\" };\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6\n    };\n    let state = STATE.NONE;\n    const EPS = 1e-6;\n    const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n    let scale = 1;\n    const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    let performCursorZoom = false;\n    const pointers = [];\n    const pointerPositions = {};\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n    function rotateLeft(angle) {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle;\n      } else {\n        sphericalDelta.theta -= angle;\n      }\n    }\n    function rotateUp(angle) {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle;\n      } else {\n        sphericalDelta.phi -= angle;\n      }\n    }\n    const panLeft = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panLeft2(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    })();\n    const panUp = (() => {\n      const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function panUp2(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    })();\n    const pan = (() => {\n      const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n      return function pan2(deltaX, deltaY) {\n        const element = scope.domElement;\n        if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n          targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n          panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n          panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n        } else if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n          panLeft(\n            deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix\n          );\n          panUp(\n            deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix\n          );\n        } else {\n          console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n          scope.enablePan = false;\n        }\n      };\n    })();\n    function setScale(newScale) {\n      if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n        scale = newScale;\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n        scope.enableZoom = false;\n      }\n    }\n    function dollyOut(dollyScale) {\n      setScale(scale / dollyScale);\n    }\n    function dollyIn(dollyScale) {\n      setScale(scale * dollyScale);\n    }\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return;\n      }\n      performCursorZoom = true;\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n      mouse.x = x / w * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n    }\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n      scope.update();\n    }\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n      dollyStart.copy(dollyEnd);\n      scope.update();\n    }\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n      scope.update();\n    }\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n      scope.update();\n    }\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          needsUpdate = true;\n          break;\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          needsUpdate = true;\n          break;\n      }\n      if (needsUpdate) {\n        event.preventDefault();\n        scope.update();\n      }\n    }\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        rotateStart.set(x, y);\n      }\n    }\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n        panStart.set(x, y);\n      }\n    }\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyStart.set(0, distance);\n    }\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enablePan)\n        handleTouchStartPan();\n    }\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom)\n        handleTouchStartDolly();\n      if (scope.enableRotate)\n        handleTouchStartRotate();\n    }\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        rotateEnd.set(x, y);\n      }\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n      const element = scope.domElement;\n      if (element) {\n        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n      }\n      rotateStart.copy(rotateEnd);\n    }\n    function handleTouchMovePan(event) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n        panEnd.set(x, y);\n      }\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n      pan(panDelta.x, panDelta.y);\n      panStart.copy(panEnd);\n    }\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      dollyEnd.set(0, distance);\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n      dollyOut(dollyDelta.y);\n      dollyStart.copy(dollyEnd);\n    }\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enablePan)\n        handleTouchMovePan(event);\n    }\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom)\n        handleTouchMoveDolly(event);\n      if (scope.enableRotate)\n        handleTouchMoveRotate(event);\n    }\n    function onPointerDown(event) {\n      var _a, _b;\n      if (scope.enabled === false)\n        return;\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n      }\n      addPointer(event);\n      if (event.pointerType === \"touch\") {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n    function onPointerMove(event) {\n      if (scope.enabled === false)\n        return;\n      if (event.pointerType === \"touch\") {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n    function onPointerUp(event) {\n      var _a, _b, _c;\n      removePointer(event);\n      if (pointers.length === 0) {\n        (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n        (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n        (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n      }\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n    function onMouseDown(event) {\n      let mouseAction;\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n        default:\n          mouseAction = -1;\n      }\n      switch (mouseAction) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseDownDolly(event);\n          state = STATE.DOLLY;\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          }\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false)\n              return;\n            handleMouseDownRotate(event);\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false)\n              return;\n            handleMouseDownPan(event);\n            state = STATE.PAN;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onMouseMove(event) {\n      if (scope.enabled === false)\n        return;\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleMouseMoveRotate(event);\n          break;\n        case STATE.DOLLY:\n          if (scope.enableZoom === false)\n            return;\n          handleMouseMoveDolly(event);\n          break;\n        case STATE.PAN:\n          if (scope.enablePan === false)\n            return;\n          handleMouseMovePan(event);\n          break;\n      }\n    }\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n        return;\n      }\n      event.preventDefault();\n      scope.dispatchEvent(startEvent);\n      handleMouseWheel(event);\n      scope.dispatchEvent(endEvent);\n    }\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false)\n        return;\n      handleKeyDown(event);\n    }\n    function onTouchStart(event) {\n      trackPointer(event);\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n              if (scope.enableRotate === false)\n                return;\n              handleTouchStartRotate();\n              state = STATE.TOUCH_ROTATE;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n              if (scope.enablePan === false)\n                return;\n              handleTouchStartPan();\n              state = STATE.TOUCH_PAN;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        case 2:\n          switch (scope.touches.TWO) {\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false)\n                return;\n              handleTouchStartDollyPan();\n              state = STATE.TOUCH_DOLLY_PAN;\n              break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false)\n                return;\n              handleTouchStartDollyRotate();\n              state = STATE.TOUCH_DOLLY_ROTATE;\n              break;\n            default:\n              state = STATE.NONE;\n          }\n          break;\n        default:\n          state = STATE.NONE;\n      }\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(startEvent);\n      }\n    }\n    function onTouchMove(event) {\n      trackPointer(event);\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false)\n            return;\n          handleTouchMoveRotate(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false)\n            return;\n          handleTouchMovePan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false)\n            return;\n          handleTouchMoveDollyPan(event);\n          scope.update();\n          break;\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false)\n            return;\n          handleTouchMoveDollyRotate(event);\n          scope.update();\n          break;\n        default:\n          state = STATE.NONE;\n      }\n    }\n    function onContextMenu(event) {\n      if (scope.enabled === false)\n        return;\n      event.preventDefault();\n    }\n    function addPointer(event) {\n      pointers.push(event);\n    }\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n      if (position === void 0) {\n        position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n      position.set(event.pageX, event.pageY);\n    }\n    function getSecondPointerPosition(event) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n      return pointerPositions[pointer.pointerId];\n    }\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale);\n      scope.update();\n    };\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n      dollyOut(dollyScale);\n      scope.update();\n    };\n    this.getScale = () => {\n      return scale;\n    };\n    this.setScale = (newScale) => {\n      setScale(newScale);\n      scope.update();\n    };\n    this.getZoomScale = () => {\n      return getZoomScale();\n    };\n    if (domElement !== void 0)\n      this.connect(domElement);\n    this.update();\n  }\n}\nclass MapControls extends OrbitControls {\n  constructor(object, domElement) {\n    super(object, domElement);\n    this.screenSpacePanning = false;\n    this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n    this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n    this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n    this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n  }\n}\n\n//# sourceMappingURL=OrbitControls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNpSTtBQUMxRTtBQUN2RCxpQkFBaUIsc0NBQUc7QUFDcEIsbUJBQW1CLHdDQUFLO0FBQ3hCO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0RUFBNEU7QUFDOUc7QUFDQTtBQUNBLFlBQVksd0NBQUs7QUFDakIsY0FBYyx3Q0FBSztBQUNuQixhQUFhLHdDQUFLO0FBQ2xCLEtBQUs7QUFDTDtBQUNBLHFDQUFxQyxLQUFLLHdDQUFLLGNBQWMsd0NBQUssWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMENBQU87QUFDaEMscUJBQXFCLDBDQUFPO0FBQzVCLHVCQUF1Qiw2Q0FBVTtBQUNqQztBQUNBLCtCQUErQiwwQ0FBTztBQUN0QyxpQ0FBaUMsNkNBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9DQUFvQywwQ0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUNBQWlDLHFEQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUztBQUNuQywrQkFBK0IsNENBQVM7QUFDeEM7QUFDQSwwQkFBMEIsMENBQU87QUFDakMsNEJBQTRCLDBDQUFPO0FBQ25DLDBCQUEwQiwwQ0FBTztBQUNqQyw0QkFBNEIsMENBQU87QUFDbkMseUJBQXlCLDBDQUFPO0FBQ2hDLHVCQUF1QiwwQ0FBTztBQUM5Qix5QkFBeUIsMENBQU87QUFDaEMsMkJBQTJCLDBDQUFPO0FBQ2xDLHlCQUF5QiwwQ0FBTztBQUNoQywyQkFBMkIsMENBQU87QUFDbEMsK0JBQStCLDBDQUFPO0FBQ3RDLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsMENBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QiwwQ0FBTztBQUNoQztBQUNBO0FBQ0EsK0NBQStDLG9EQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QyxxREFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxvREFBaUIsZ0VBQWdFLHFEQUFrQjtBQUNySTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdDQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdDQUFLO0FBQ2xDLDhCQUE4Qix3Q0FBSztBQUNuQyx1QkFBdUIsd0NBQUs7QUFDNUIsdUJBQXVCLHdDQUFLO0FBQzVCO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc25pcGVyLWFpLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9jb250cm9scy9PcmJpdENvbnRyb2xzLmpzPzFhMTciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuaW1wb3J0IHsgUmF5LCBQbGFuZSwgVmVjdG9yMywgTU9VU0UsIFRPVUNILCBRdWF0ZXJuaW9uLCBQZXJzcGVjdGl2ZUNhbWVyYSwgT3J0aG9ncmFwaGljQ2FtZXJhLCBTcGhlcmljYWwsIFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCIuL0V2ZW50RGlzcGF0Y2hlci5qc1wiO1xuY29uc3QgX3JheSA9IG5ldyBSYXkoKTtcbmNvbnN0IF9wbGFuZSA9IG5ldyBQbGFuZSgpO1xuY29uc3QgVElMVF9MSU1JVCA9IE1hdGguY29zKDcwICogKE1hdGguUEkgLyAxODApKTtcbmNvbnN0IG1vZHVsb1dyYXBBcm91bmQgPSAob2Zmc2V0LCBjYXBhY2l0eSkgPT4gKG9mZnNldCAlIGNhcGFjaXR5ICsgY2FwYWNpdHkpICUgY2FwYWNpdHk7XG5jbGFzcyBPcmJpdENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib2JqZWN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb21FbGVtZW50XCIpO1xuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YXJnZXRcIiwgbmV3IFZlY3RvcjMoKSk7XG4gICAgLy8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluRGlzdGFuY2VcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heERpc3RhbmNlXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5ab29tXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhab29tXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cbiAgICAvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluUG9sYXJBbmdsZVwiLCAwKTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heFBvbGFyQW5nbGVcIiwgTWF0aC5QSSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gSWYgc2V0LCB0aGUgaW50ZXJ2YWwgWyBtaW4sIG1heCBdIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgWyAtIDIgUEksIDIgUEkgXSwgd2l0aCAoIG1heCAtIG1pbiA8IDIgUEkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5BemltdXRoQW5nbGVcIiwgLUluZmluaXR5KTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heEF6aW11dGhBbmdsZVwiLCBJbmZpbml0eSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuICAgIC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZURhbXBpbmdcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYW1waW5nRmFjdG9yXCIsIDAuMDUpO1xuICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVab29tXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ6b29tU3BlZWRcIiwgMSk7XG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlUm90YXRlXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb3RhdGVTcGVlZFwiLCAxKTtcbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZVBhblwiLCB0cnVlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFuU3BlZWRcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjcmVlblNwYWNlUGFubmluZ1wiLCB0cnVlKTtcbiAgICAvLyBpZiBmYWxzZSwgcGFuIG9ydGhvZ29uYWwgdG8gd29ybGQtc3BhY2UgZGlyZWN0aW9uIGNhbWVyYS51cFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJrZXlQYW5TcGVlZFwiLCA3KTtcbiAgICAvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInpvb21Ub0N1cnNvclwiLCBmYWxzZSk7XG4gICAgLy8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcbiAgICAvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0b1JvdGF0ZVwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dG9Sb3RhdGVTcGVlZFwiLCAyKTtcbiAgICAvLyAzMCBzZWNvbmRzIHBlciBvcmJpdCB3aGVuIGZwcyBpcyA2MFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlT3JiaXRcIiwgZmFsc2UpO1xuICAgIC8vIHRydWUgaWYgeW91IHdhbnQgdG8gcmV2ZXJzZSB0aGUgb3JiaXQgdG8gbW91c2UgZHJhZyBmcm9tIGxlZnQgdG8gcmlnaHQgPSBvcmJpdHMgbGVmdFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlSG9yaXpvbnRhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIGhvcml6b250YWwgb3JiaXQgZGlyZWN0aW9uXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJldmVyc2VWZXJ0aWNhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIHZlcnRpY2FsIG9yYml0IGRpcmVjdGlvblxuICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5c1wiLCB7IExFRlQ6IFwiQXJyb3dMZWZ0XCIsIFVQOiBcIkFycm93VXBcIiwgUklHSFQ6IFwiQXJyb3dSaWdodFwiLCBCT1RUT006IFwiQXJyb3dEb3duXCIgfSk7XG4gICAgLy8gTW91c2UgYnV0dG9uc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3VzZUJ1dHRvbnNcIiwge1xuICAgICAgTEVGVDogTU9VU0UuUk9UQVRFLFxuICAgICAgTUlERExFOiBNT1VTRS5ET0xMWSxcbiAgICAgIFJJR0hUOiBNT1VTRS5QQU5cbiAgICB9KTtcbiAgICAvLyBUb3VjaCBmaW5nZXJzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvdWNoZXNcIiwgeyBPTkU6IFRPVUNILlJPVEFURSwgVFdPOiBUT1VDSC5ET0xMWV9QQU4gfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhcmdldDBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uMFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiem9vbTBcIik7XG4gICAgLy8gdGhlIHRhcmdldCBET00gZWxlbWVudCBmb3Iga2V5IGV2ZW50c1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZG9tRWxlbWVudEtleUV2ZW50c1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UG9sYXJBbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QXppbXV0aGFsQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFBvbGFyQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEF6aW11dGhhbEFuZ2xlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXREaXN0YW5jZVwiKTtcbiAgICAvLyBOb3QgdXNlZCBpbiBtb3N0IHNjZW5hcmlvcywgaG93ZXZlciB0aGV5IGNhbiBiZSB1c2VmdWwgZm9yIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRab29tU2NhbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpc3RlblRvS2V5RXZlbnRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wTGlzdGVuVG9LZXlFdmVudHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNhdmVTdGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwZGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29ubmVjdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGlzcG9zZVwiKTtcbiAgICAvLyBEb2xseSBpbiBwcm9ncmFtbWF0aWNhbGx5XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvbGx5SW5cIik7XG4gICAgLy8gRG9sbHkgb3V0IHByb2dyYW1tYXRpY2FsbHlcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9sbHlPdXRcIik7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHNjYWxlXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFNjYWxlXCIpO1xuICAgIC8vIFNldCB0aGUgY3VycmVudCBzY2FsZSAodGhlc2UgYXJlIG5vdCB1c2VkIGluIG1vc3Qgc2NlbmFyaW9zLCBob3dldmVyIHRoZXkgY2FuIGJlIHVzZWZ1bCBmb3Igc3BlY2lmaWMgdXNlIGNhc2VzKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRTY2FsZVwiKTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIHRoaXMuem9vbTAgPSB0aGlzLm9iamVjdC56b29tO1xuICAgIHRoaXMuZ2V0UG9sYXJBbmdsZSA9ICgpID0+IHNwaGVyaWNhbC5waGk7XG4gICAgdGhpcy5nZXRBemltdXRoYWxBbmdsZSA9ICgpID0+IHNwaGVyaWNhbC50aGV0YTtcbiAgICB0aGlzLnNldFBvbGFyQW5nbGUgPSAodmFsdWUpID0+IHtcbiAgICAgIGxldCBwaGkgPSBtb2R1bG9XcmFwQXJvdW5kKHZhbHVlLCAyICogTWF0aC5QSSk7XG4gICAgICBsZXQgY3VycmVudFBoaSA9IHNwaGVyaWNhbC5waGk7XG4gICAgICBpZiAoY3VycmVudFBoaSA8IDApXG4gICAgICAgIGN1cnJlbnRQaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICBpZiAocGhpIDwgMClcbiAgICAgICAgcGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgbGV0IHBoaURpc3QgPSBNYXRoLmFicyhwaGkgLSBjdXJyZW50UGhpKTtcbiAgICAgIGlmICgyICogTWF0aC5QSSAtIHBoaURpc3QgPCBwaGlEaXN0KSB7XG4gICAgICAgIGlmIChwaGkgPCBjdXJyZW50UGhpKSB7XG4gICAgICAgICAgcGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSA9IHBoaSAtIGN1cnJlbnRQaGk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0QXppbXV0aGFsQW5nbGUgPSAodmFsdWUpID0+IHtcbiAgICAgIGxldCB0aGV0YSA9IG1vZHVsb1dyYXBBcm91bmQodmFsdWUsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGxldCBjdXJyZW50VGhldGEgPSBzcGhlcmljYWwudGhldGE7XG4gICAgICBpZiAoY3VycmVudFRoZXRhIDwgMClcbiAgICAgICAgY3VycmVudFRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgaWYgKHRoZXRhIDwgMClcbiAgICAgICAgdGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICBsZXQgdGhldGFEaXN0ID0gTWF0aC5hYnModGhldGEgLSBjdXJyZW50VGhldGEpO1xuICAgICAgaWYgKDIgKiBNYXRoLlBJIC0gdGhldGFEaXN0IDwgdGhldGFEaXN0KSB7XG4gICAgICAgIGlmICh0aGV0YSA8IGN1cnJlbnRUaGV0YSkge1xuICAgICAgICAgIHRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRUaGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgPSB0aGV0YSAtIGN1cnJlbnRUaGV0YTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXREaXN0YW5jZSA9ICgpID0+IHNjb3BlLm9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKHNjb3BlLnRhcmdldCk7XG4gICAgdGhpcy5saXN0ZW5Ub0tleUV2ZW50cyA9IChkb21FbGVtZW50MikgPT4ge1xuICAgICAgZG9tRWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBkb21FbGVtZW50MjtcbiAgICB9O1xuICAgIHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLnNhdmVTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHNjb3BlLnRhcmdldDAuY29weShzY29wZS50YXJnZXQpO1xuICAgICAgc2NvcGUucG9zaXRpb24wLmNvcHkoc2NvcGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgIHNjb3BlLnpvb20wID0gc2NvcGUub2JqZWN0Lnpvb207XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgc2NvcGUudGFyZ2V0LmNvcHkoc2NvcGUudGFyZ2V0MCk7XG4gICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uY29weShzY29wZS5wb3NpdGlvbjApO1xuICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcbiAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSAoKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICBjb25zdCBxdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMob2JqZWN0LnVwLCB1cCk7XG4gICAgICBjb25zdCBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICAgIGNvbnN0IGxhc3RQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjb25zdCBsYXN0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICBjb25zdCB0d29QSSA9IDIgKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgdXApO1xuICAgICAgICBxdWF0SW52ZXJzZS5jb3B5KHF1YXQpLmludmVydCgpO1xuICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHNjb3BlLnRhcmdldCk7XG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdCk7XG4gICAgICAgIHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyhvZmZzZXQpO1xuICAgICAgICBpZiAoc2NvcGUuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xuICAgICAgICAgIHJvdGF0ZUxlZnQoZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcpIHtcbiAgICAgICAgICBzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGEgKiBzY29wZS5kYW1waW5nRmFjdG9yO1xuICAgICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpICogc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG4gICAgICAgICAgc3BoZXJpY2FsLnBoaSArPSBzcGhlcmljYWxEZWx0YS5waGk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbiA9IHNjb3BlLm1pbkF6aW11dGhBbmdsZTtcbiAgICAgICAgbGV0IG1heCA9IHNjb3BlLm1heEF6aW11dGhBbmdsZTtcbiAgICAgICAgaWYgKGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUobWF4KSkge1xuICAgICAgICAgIGlmIChtaW4gPCAtTWF0aC5QSSlcbiAgICAgICAgICAgIG1pbiArPSB0d29QSTtcbiAgICAgICAgICBlbHNlIGlmIChtaW4gPiBNYXRoLlBJKVxuICAgICAgICAgICAgbWluIC09IHR3b1BJO1xuICAgICAgICAgIGlmIChtYXggPCAtTWF0aC5QSSlcbiAgICAgICAgICAgIG1heCArPSB0d29QSTtcbiAgICAgICAgICBlbHNlIGlmIChtYXggPiBNYXRoLlBJKVxuICAgICAgICAgICAgbWF4IC09IHR3b1BJO1xuICAgICAgICAgIGlmIChtaW4gPD0gbWF4KSB7XG4gICAgICAgICAgICBzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgc3BoZXJpY2FsLnRoZXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSA9IHNwaGVyaWNhbC50aGV0YSA+IChtaW4gKyBtYXgpIC8gMiA/IE1hdGgubWF4KG1pbiwgc3BoZXJpY2FsLnRoZXRhKSA6IE1hdGgubWluKG1heCwgc3BoZXJpY2FsLnRoZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KHNjb3BlLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkpKTtcbiAgICAgICAgc3BoZXJpY2FsLm1ha2VTYWZlKCk7XG4gICAgICAgIGlmIChzY29wZS5lbmFibGVEYW1waW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgc2NvcGUudGFyZ2V0LmFkZFNjYWxlZFZlY3RvcihwYW5PZmZzZXQsIHNjb3BlLmRhbXBpbmdGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlLnRhcmdldC5hZGQocGFuT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuem9vbVRvQ3Vyc29yICYmIHBlcmZvcm1DdXJzb3Jab29tIHx8IHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBjbGFtcERpc3RhbmNlKHNwaGVyaWNhbC5yYWRpdXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBjbGFtcERpc3RhbmNlKHNwaGVyaWNhbC5yYWRpdXMgKiBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0LnNldEZyb21TcGhlcmljYWwoc3BoZXJpY2FsKTtcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0SW52ZXJzZSk7XG4gICAgICAgIHBvc2l0aW9uLmNvcHkoc2NvcGUudGFyZ2V0KS5hZGQob2Zmc2V0KTtcbiAgICAgICAgaWYgKCFzY29wZS5vYmplY3QubWF0cml4QXV0b1VwZGF0ZSlcbiAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHNjb3BlLm9iamVjdC5sb29rQXQoc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKj0gMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgcGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKDEgLSBzY29wZS5kYW1waW5nRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgcGFuT2Zmc2V0LnNldCgwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjb3BlLnpvb21Ub0N1cnNvciAmJiBwZXJmb3JtQ3Vyc29yWm9vbSkge1xuICAgICAgICAgIGxldCBuZXdSYWRpdXMgPSBudWxsO1xuICAgICAgICAgIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgY29uc3QgcHJldlJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcbiAgICAgICAgICAgIG5ld1JhZGl1cyA9IGNsYW1wRGlzdGFuY2UocHJldlJhZGl1cyAqIHNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1c0RlbHRhID0gcHJldlJhZGl1cyAtIG5ld1JhZGl1cztcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5wb3NpdGlvbi5hZGRTY2FsZWRWZWN0b3IoZG9sbHlEaXJlY3Rpb24sIHJhZGl1c0RlbHRhKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZUJlZm9yZSA9IG5ldyBWZWN0b3IzKG1vdXNlLngsIG1vdXNlLnksIDApO1xuICAgICAgICAgICAgbW91c2VCZWZvcmUudW5wcm9qZWN0KHNjb3BlLm9iamVjdCk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KHNjb3BlLm1pblpvb20sIE1hdGgubWluKHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gc2NhbGUpKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBtb3VzZUFmdGVyID0gbmV3IFZlY3RvcjMobW91c2UueCwgbW91c2UueSwgMCk7XG4gICAgICAgICAgICBtb3VzZUFmdGVyLnVucHJvamVjdChzY29wZS5vYmplY3QpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnBvc2l0aW9uLnN1Yihtb3VzZUFmdGVyKS5hZGQobW91c2VCZWZvcmUpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgICBuZXdSYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHpvb20gdG8gY3Vyc29yIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICAgIHNjb3BlLnpvb21Ub0N1cnNvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3UmFkaXVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuc2NyZWVuU3BhY2VQYW5uaW5nKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnRhcmdldC5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihzY29wZS5vYmplY3QubWF0cml4KS5tdWx0aXBseVNjYWxhcihuZXdSYWRpdXMpLmFkZChzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3JheS5vcmlnaW4uY29weShzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgICAgICBfcmF5LmRpcmVjdGlvbi5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihzY29wZS5vYmplY3QubWF0cml4KTtcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNjb3BlLm9iamVjdC51cC5kb3QoX3JheS5kaXJlY3Rpb24pKSA8IFRJTFRfTElNSVQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubG9va0F0KHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHNjb3BlLm9iamVjdC51cCwgc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBfcmF5LmludGVyc2VjdFBsYW5lKF9wbGFuZSwgc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgem9vbUNoYW5nZWQgPSBzY2FsZSAhPT0gMTtcbiAgICAgICAgICBpZiAoem9vbUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoc2NvcGUubWluWm9vbSwgTWF0aC5taW4oc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBzY2FsZSkpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICBwZXJmb3JtQ3Vyc29yWm9vbSA9IGZhbHNlO1xuICAgICAgICBpZiAoem9vbUNoYW5nZWQgfHwgbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKHNjb3BlLm9iamVjdC5wb3NpdGlvbikgPiBFUFMgfHwgOCAqICgxIC0gbGFzdFF1YXRlcm5pb24uZG90KHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uKSkgPiBFUFMpIHtcbiAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgICAgICBsYXN0UG9zaXRpb24uY29weShzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgIGxhc3RRdWF0ZXJuaW9uLmNvcHkoc2NvcGUub2JqZWN0LnF1YXRlcm5pb24pO1xuICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMuY29ubmVjdCA9IChkb21FbGVtZW50MikgPT4ge1xuICAgICAgc2NvcGUuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQyO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvblBvaW50ZXJEb3duKTtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXApO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgb25Nb3VzZVdoZWVsKTtcbiAgICB9O1xuICAgIHRoaXMuZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgaWYgKHNjb3BlLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwiYXV0b1wiO1xuICAgICAgfVxuICAgICAgKF9hID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgIChfYiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93bik7XG4gICAgICAoX2MgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXApO1xuICAgICAgKF9kID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbk1vdXNlV2hlZWwpO1xuICAgICAgKF9lID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgKF9mID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICBpZiAoc2NvcGUuX2RvbUVsZW1lbnRLZXlFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgc2NvcGUuX2RvbUVsZW1lbnRLZXlFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IHsgdHlwZTogXCJjaGFuZ2VcIiB9O1xuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB7IHR5cGU6IFwic3RhcnRcIiB9O1xuICAgIGNvbnN0IGVuZEV2ZW50ID0geyB0eXBlOiBcImVuZFwiIH07XG4gICAgY29uc3QgU1RBVEUgPSB7XG4gICAgICBOT05FOiAtMSxcbiAgICAgIFJPVEFURTogMCxcbiAgICAgIERPTExZOiAxLFxuICAgICAgUEFOOiAyLFxuICAgICAgVE9VQ0hfUk9UQVRFOiAzLFxuICAgICAgVE9VQ0hfUEFOOiA0LFxuICAgICAgVE9VQ0hfRE9MTFlfUEFOOiA1LFxuICAgICAgVE9VQ0hfRE9MTFlfUk9UQVRFOiA2XG4gICAgfTtcbiAgICBsZXQgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIGNvbnN0IEVQUyA9IDFlLTY7XG4gICAgY29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xuICAgIGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFNwaGVyaWNhbCgpO1xuICAgIGxldCBzY2FsZSA9IDE7XG4gICAgY29uc3QgcGFuT2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCByb3RhdGVTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgcm90YXRlRW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCByb3RhdGVEZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHBhbkVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5U3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5RW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseURlbHRhID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgbW91c2UgPSBuZXcgVmVjdG9yMigpO1xuICAgIGxldCBwZXJmb3JtQ3Vyc29yWm9vbSA9IGZhbHNlO1xuICAgIGNvbnN0IHBvaW50ZXJzID0gW107XG4gICAgY29uc3QgcG9pbnRlclBvc2l0aW9ucyA9IHt9O1xuICAgIGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDAuOTUsIHNjb3BlLnpvb21TcGVlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0ZUxlZnQoYW5nbGUpIHtcbiAgICAgIGlmIChzY29wZS5yZXZlcnNlT3JiaXQgfHwgc2NvcGUucmV2ZXJzZUhvcml6b250YWxPcmJpdCkge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSArPSBhbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGVVcChhbmdsZSkge1xuICAgICAgaWYgKHNjb3BlLnJldmVyc2VPcmJpdCB8fCBzY29wZS5yZXZlcnNlVmVydGljYWxPcmJpdCkge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKz0gYW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhbkxlZnQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuTGVmdDIoZGlzdGFuY2UsIG9iamVjdE1hdHJpeCkge1xuICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAwKTtcbiAgICAgICAgdi5tdWx0aXBseVNjYWxhcigtZGlzdGFuY2UpO1xuICAgICAgICBwYW5PZmZzZXQuYWRkKHYpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHBhblVwID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhblVwMihkaXN0YW5jZSwgb2JqZWN0TWF0cml4KSB7XG4gICAgICAgIGlmIChzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAwKTtcbiAgICAgICAgICB2LmNyb3NzVmVjdG9ycyhzY29wZS5vYmplY3QudXAsIHYpO1xuICAgICAgICB9XG4gICAgICAgIHYubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpO1xuICAgICAgICBwYW5PZmZzZXQuYWRkKHYpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHBhbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbjIoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQ7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgb2Zmc2V0LmNvcHkocG9zaXRpb24pLnN1YihzY29wZS50YXJnZXQpO1xuICAgICAgICAgIGxldCB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcbiAgICAgICAgICB0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbihzY29wZS5vYmplY3QuZm92IC8gMiAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgIHBhbkxlZnQoMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXgpO1xuICAgICAgICAgIHBhblVwKDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICBwYW5MZWZ0KFxuICAgICAgICAgICAgZGVsdGFYICogKHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0KSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5tYXRyaXhcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhblVwKFxuICAgICAgICAgICAgZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBzY29wZS5vYmplY3QubWF0cml4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuXCIpO1xuICAgICAgICAgIHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgZnVuY3Rpb24gc2V0U2NhbGUobmV3U2NhbGUpIHtcbiAgICAgIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSB8fCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgIHNjYWxlID0gbmV3U2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLlwiKTtcbiAgICAgICAgc2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb2xseU91dChkb2xseVNjYWxlKSB7XG4gICAgICBzZXRTY2FsZShzY2FsZSAvIGRvbGx5U2NhbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2xseUluKGRvbGx5U2NhbGUpIHtcbiAgICAgIHNldFNjYWxlKHNjYWxlICogZG9sbHlTY2FsZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1vdXNlUGFyYW1ldGVycyhldmVudCkge1xuICAgICAgaWYgKCFzY29wZS56b29tVG9DdXJzb3IgfHwgIXNjb3BlLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVyZm9ybUN1cnNvclpvb20gPSB0cnVlO1xuICAgICAgY29uc3QgcmVjdCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICBjb25zdCB3ID0gcmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGggPSByZWN0LmhlaWdodDtcbiAgICAgIG1vdXNlLnggPSB4IC8gdyAqIDIgLSAxO1xuICAgICAgbW91c2UueSA9IC0oeSAvIGgpICogMiArIDE7XG4gICAgICBkb2xseURpcmVjdGlvbi5zZXQobW91c2UueCwgbW91c2UueSwgMSkudW5wcm9qZWN0KHNjb3BlLm9iamVjdCkuc3ViKHNjb3BlLm9iamVjdC5wb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYW1wRGlzdGFuY2UoZGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbihzY29wZS5tYXhEaXN0YW5jZSwgZGlzdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpIHtcbiAgICAgIHJvdGF0ZVN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duRG9sbHkoZXZlbnQpIHtcbiAgICAgIHVwZGF0ZU1vdXNlUGFyYW1ldGVycyhldmVudCk7XG4gICAgICBkb2xseVN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUGFuKGV2ZW50KSB7XG4gICAgICBwYW5TdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZShldmVudCkge1xuICAgICAgcm90YXRlRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucm90YXRlU3BlZWQpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByb3RhdGVMZWZ0KDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgcm90YXRlVXAoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KGV2ZW50KSB7XG4gICAgICBkb2xseUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoZG9sbHlFbmQsIGRvbGx5U3RhcnQpO1xuICAgICAgaWYgKGRvbGx5RGVsdGEueSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfSBlbHNlIGlmIChkb2xseURlbHRhLnkgPCAwKSB7XG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfVxuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oZXZlbnQpIHtcbiAgICAgIHBhbkVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnBhblNwZWVkKTtcbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlbHRhWSA8IDApIHtcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhWSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfVxuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5VUDpcbiAgICAgICAgICBwYW4oMCwgc2NvcGUua2V5UGFuU3BlZWQpO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcbiAgICAgICAgICBwYW4oMCwgLXNjb3BlLmtleVBhblNwZWVkKTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuICAgICAgICAgIHBhbihzY29wZS5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG4gICAgICAgICAgcGFuKC1zY29wZS5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJvdGF0ZVN0YXJ0LnNldChwb2ludGVyc1swXS5wYWdlWCwgcG9pbnRlcnNbMF0ucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWSArIHBvaW50ZXJzWzFdLnBhZ2VZKTtcbiAgICAgICAgcm90YXRlU3RhcnQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0UGFuKCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHBhblN0YXJ0LnNldChwb2ludGVyc1swXS5wYWdlWCwgcG9pbnRlcnNbMF0ucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWSArIHBvaW50ZXJzWzFdLnBhZ2VZKTtcbiAgICAgICAgcGFuU3RhcnQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKSB7XG4gICAgICBjb25zdCBkeCA9IHBvaW50ZXJzWzBdLnBhZ2VYIC0gcG9pbnRlcnNbMV0ucGFnZVg7XG4gICAgICBjb25zdCBkeSA9IHBvaW50ZXJzWzBdLnBhZ2VZIC0gcG9pbnRlcnNbMV0ucGFnZVk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkb2xseVN0YXJ0LnNldCgwLCBkaXN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbigpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVQYW4pXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnRQYW4oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseSgpO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSlcbiAgICAgICAgaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKiAoZXZlbnQucGFnZVggKyBwb3NpdGlvbi54KTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChldmVudC5wYWdlWSArIHBvc2l0aW9uLnkpO1xuICAgICAgICByb3RhdGVFbmQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5yb3RhdGVTcGVlZCk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJvdGF0ZUxlZnQoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICByb3RhdGVVcCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICByb3RhdGVTdGFydC5jb3B5KHJvdGF0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHBhbkVuZC5zZXQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChldmVudC5wYWdlWCArIHBvc2l0aW9uLngpO1xuICAgICAgICBjb25zdCB5ID0gMC41ICogKGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSk7XG4gICAgICAgIHBhbkVuZC5zZXQoeCwgeSk7XG4gICAgICB9XG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnBhblNwZWVkKTtcbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgIGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuICAgICAgY29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkb2xseUVuZC5zZXQoMCwgZGlzdGFuY2UpO1xuICAgICAgZG9sbHlEZWx0YS5zZXQoMCwgTWF0aC5wb3coZG9sbHlFbmQueSAvIGRvbGx5U3RhcnQueSwgc2NvcGUuem9vbVNwZWVkKSk7XG4gICAgICBkb2xseU91dChkb2xseURlbHRhLnkpO1xuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudCk7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVQYW4oZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5KGV2ZW50KTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUpXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZShldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgKF9hID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICAoX2IgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIH1cbiAgICAgIGFkZFBvaW50ZXIoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgb25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICBvblRvdWNoTW92ZShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHJlbW92ZVBvaW50ZXIoZXZlbnQpO1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAoX2EgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIChfYiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgKF9jID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICB9XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGxldCBtb3VzZUFjdGlvbjtcbiAgICAgIHN3aXRjaCAoZXZlbnQuYnV0dG9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5MRUZUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTUlERExFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobW91c2VBY3Rpb24pIHtcbiAgICAgICAgY2FzZSBNT1VTRS5ET0xMWTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlTW91c2VEb3duRG9sbHkoZXZlbnQpO1xuICAgICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTU9VU0UuUk9UQVRFOlxuICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5ST1RBVEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1PVVNFLlBBTjpcbiAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUGFuKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNUQVRFLlJPVEFURTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLkRPTExZOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVEb2xseShldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZVBhbihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlIHx8IHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBoYW5kbGVLZXlEb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICB0cmFja1BvaW50ZXIoZXZlbnQpO1xuICAgICAgc3dpdGNoIChwb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHN3aXRjaCAoc2NvcGUudG91Y2hlcy5PTkUpIHtcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guUk9UQVRFOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5QQU46XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydFBhbigpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc3dpdGNoIChzY29wZS50b3VjaGVzLlRXTykge1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5ET0xMWV9QQU46XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5UGFuKCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUEFOO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guRE9MTFlfUk9UQVRFOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSgpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgdHJhY2tQb2ludGVyKGV2ZW50KTtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ST1RBVEU6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9QQU46XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oZXZlbnQpO1xuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZShldmVudCk7XG4gICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGV2ZW50KSB7XG4gICAgICBkZWxldGUgcG9pbnRlclBvc2l0aW9uc1tldmVudC5wb2ludGVySWRdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9pbnRlcnNbaV0ucG9pbnRlcklkID09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2tQb2ludGVyKGV2ZW50KSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSBwb2ludGVyUG9zaXRpb25zW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICBwb3NpdGlvbiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIHBvaW50ZXJQb3NpdGlvbnNbZXZlbnQucG9pbnRlcklkXSA9IHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24uc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCkge1xuICAgICAgY29uc3QgcG9pbnRlciA9IGV2ZW50LnBvaW50ZXJJZCA9PT0gcG9pbnRlcnNbMF0ucG9pbnRlcklkID8gcG9pbnRlcnNbMV0gOiBwb2ludGVyc1swXTtcbiAgICAgIHJldHVybiBwb2ludGVyUG9zaXRpb25zW3BvaW50ZXIucG9pbnRlcklkXTtcbiAgICB9XG4gICAgdGhpcy5kb2xseUluID0gKGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKSkgPT4ge1xuICAgICAgZG9sbHlJbihkb2xseVNjYWxlKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5kb2xseU91dCA9IChkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCkpID0+IHtcbiAgICAgIGRvbGx5T3V0KGRvbGx5U2NhbGUpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNjYWxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgdGhpcy5zZXRTY2FsZSA9IChuZXdTY2FsZSkgPT4ge1xuICAgICAgc2V0U2NhbGUobmV3U2NhbGUpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFpvb21TY2FsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBnZXRab29tU2NhbGUoKTtcbiAgICB9O1xuICAgIGlmIChkb21FbGVtZW50ICE9PSB2b2lkIDApXG4gICAgICB0aGlzLmNvbm5lY3QoZG9tRWxlbWVudCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxufVxuY2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBPcmJpdENvbnRyb2xzIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIob2JqZWN0LCBkb21FbGVtZW50KTtcbiAgICB0aGlzLnNjcmVlblNwYWNlUGFubmluZyA9IGZhbHNlO1xuICAgIHRoaXMubW91c2VCdXR0b25zLkxFRlQgPSBNT1VTRS5QQU47XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuUklHSFQgPSBNT1VTRS5ST1RBVEU7XG4gICAgdGhpcy50b3VjaGVzLk9ORSA9IFRPVUNILlBBTjtcbiAgICB0aGlzLnRvdWNoZXMuVFdPID0gVE9VQ0guRE9MTFlfUk9UQVRFO1xuICB9XG59XG5leHBvcnQge1xuICBNYXBDb250cm9scyxcbiAgT3JiaXRDb250cm9sc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yYml0Q29udHJvbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/geometries/TextGeometry.js":
/*!**************************************************************!*\
  !*** ./node_modules/three-stdlib/geometries/TextGeometry.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextBufferGeometry: () => (/* binding */ TextGeometry),\n/* harmony export */   TextGeometry: () => (/* binding */ TextGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass TextGeometry extends three__WEBPACK_IMPORTED_MODULE_0__.ExtrudeGeometry {\n  constructor(text, parameters = {}) {\n    const {\n      bevelEnabled = false,\n      bevelSize = 8,\n      bevelThickness = 10,\n      font,\n      height = 50,\n      size = 100,\n      lineHeight = 1,\n      letterSpacing = 0,\n      ...rest\n    } = parameters;\n    if (font === void 0) {\n      super();\n    } else {\n      const shapes = font.generateShapes(text, size, { lineHeight, letterSpacing });\n      super(shapes, { ...rest, bevelEnabled, bevelSize, bevelThickness, depth: height });\n    }\n    this.type = \"TextGeometry\";\n  }\n}\n\n//# sourceMappingURL=TextGeometry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QztBQUN4QywyQkFBMkIsa0RBQWU7QUFDMUMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdURBQXVELDJCQUEyQjtBQUNsRixzQkFBc0IsaUVBQWlFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NuaXBlci1haS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanM/ODFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRydWRlR2VvbWV0cnkgfSBmcm9tIFwidGhyZWVcIjtcbmNsYXNzIFRleHRHZW9tZXRyeSBleHRlbmRzIEV4dHJ1ZGVHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKHRleHQsIHBhcmFtZXRlcnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJldmVsRW5hYmxlZCA9IGZhbHNlLFxuICAgICAgYmV2ZWxTaXplID0gOCxcbiAgICAgIGJldmVsVGhpY2tuZXNzID0gMTAsXG4gICAgICBmb250LFxuICAgICAgaGVpZ2h0ID0gNTAsXG4gICAgICBzaXplID0gMTAwLFxuICAgICAgbGluZUhlaWdodCA9IDEsXG4gICAgICBsZXR0ZXJTcGFjaW5nID0gMCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBpZiAoZm9udCA9PT0gdm9pZCAwKSB7XG4gICAgICBzdXBlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaGFwZXMgPSBmb250LmdlbmVyYXRlU2hhcGVzKHRleHQsIHNpemUsIHsgbGluZUhlaWdodCwgbGV0dGVyU3BhY2luZyB9KTtcbiAgICAgIHN1cGVyKHNoYXBlcywgeyAuLi5yZXN0LCBiZXZlbEVuYWJsZWQsIGJldmVsU2l6ZSwgYmV2ZWxUaGlja25lc3MsIGRlcHRoOiBoZWlnaHQgfSk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IFwiVGV4dEdlb21ldHJ5XCI7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFRleHRHZW9tZXRyeSBhcyBUZXh0QnVmZmVyR2VvbWV0cnksXG4gIFRleHRHZW9tZXRyeVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRHZW9tZXRyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/geometries/TextGeometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/FontLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/FontLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontLoader: () => (/* binding */ FontLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nclass FontLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== \"string\")\n          throw new Error(\"unsupported data type\");\n        const json = JSON.parse(response);\n        const font = this.parse(json);\n        if (onLoad)\n          onLoad(font);\n      },\n      onProgress,\n      onError\n    );\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0, offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return { offsetX: glyph.ha * scale, path };\n}\n\n//# sourceMappingURL=FontLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRm9udExvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDdEQseUJBQXlCLHlDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NuaXBlci1haS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9Gb250TG9hZGVyLmpzP2U1ZDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBTaGFwZVBhdGggfSBmcm9tIFwidGhyZWVcIjtcbmNsYXNzIEZvbnRMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgZGF0YSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLnBhcnNlKGpzb24pO1xuICAgICAgICBpZiAob25Mb2FkKVxuICAgICAgICAgIG9uTG9hZChmb250KTtcbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25FcnJvclxuICAgICk7XG4gIH1cbiAgbG9hZEFzeW5jKHVybCwgb25Qcm9ncmVzcykge1xuICAgIHJldHVybiBzdXBlci5sb2FkQXN5bmModXJsLCBvblByb2dyZXNzKTtcbiAgfVxuICBwYXJzZShqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBGb250KGpzb24pO1xuICB9XG59XG5jbGFzcyBGb250IHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhXCIpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2VuZXJhdGVTaGFwZXModGV4dCwgc2l6ZSA9IDEwMCwgX29wdGlvbnMpIHtcbiAgICBjb25zdCBzaGFwZXMgPSBbXTtcbiAgICBjb25zdCBvcHRpb25zID0geyBsZXR0ZXJTcGFjaW5nOiAwLCBsaW5lSGVpZ2h0OiAxLCAuLi5fb3B0aW9ucyB9O1xuICAgIGNvbnN0IHBhdGhzID0gY3JlYXRlUGF0aHModGV4dCwgc2l6ZSwgdGhpcy5kYXRhLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCsrKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzaGFwZXMsIHBhdGhzW3BdLnRvU2hhcGVzKGZhbHNlKSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZXM7XG4gIH1cbn1cbl9fcHVibGljRmllbGQoRm9udCwgXCJpc0ZvbnRcIik7XG5fX3B1YmxpY0ZpZWxkKEZvbnQsIFwidHlwZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhzKHRleHQsIHNpemUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnMgPSBBcnJheS5mcm9tKHRleHQpO1xuICBjb25zdCBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XG4gIGNvbnN0IGxpbmVfaGVpZ2h0ID0gKGRhdGEuYm91bmRpbmdCb3gueU1heCAtIGRhdGEuYm91bmRpbmdCb3gueU1pbiArIGRhdGEudW5kZXJsaW5lVGhpY2tuZXNzKSAqIHNjYWxlO1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBsZXQgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGNoYXJzW2ldO1xuICAgIGlmIChjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICAgIG9mZnNldFkgLT0gbGluZV9oZWlnaHQgKiBvcHRpb25zLmxpbmVIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJldCA9IGNyZWF0ZVBhdGgoY2hhciwgc2NhbGUsIG9mZnNldFgsIG9mZnNldFksIGRhdGEpO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICBvZmZzZXRYICs9IHJldC5vZmZzZXRYICsgb3B0aW9ucy5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICBwYXRocy5wdXNoKHJldC5wYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGhzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aChjaGFyLCBzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSwgZGF0YSkge1xuICBjb25zdCBnbHlwaCA9IGRhdGEuZ2x5cGhzW2NoYXJdIHx8IGRhdGEuZ2x5cGhzW1wiP1wiXTtcbiAgaWYgKCFnbHlwaCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkZvbnQ6IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGRvZXMgbm90IGV4aXN0cyBpbiBmb250IGZhbWlseSAnICsgZGF0YS5mYW1pbHlOYW1lICsgXCIuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICBsZXQgeCwgeSwgY3B4LCBjcHksIGNweDEsIGNweTEsIGNweDIsIGNweTI7XG4gIGlmIChnbHlwaC5vKSB7XG4gICAgY29uc3Qgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8IChnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoXCIgXCIpKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBvdXRsaW5lW2krK107XG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHggPSBwYXJzZUludChvdXRsaW5lW2krK10pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgICAgIHkgPSBwYXJzZUludChvdXRsaW5lW2krK10pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgICAgIHBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgIHggPSBwYXJzZUludChvdXRsaW5lW2krK10pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgICAgIHkgPSBwYXJzZUludChvdXRsaW5lW2krK10pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgIGNweCA9IHBhcnNlSW50KG91dGxpbmVbaSsrXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICAgICAgY3B5ID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgICAgICBjcHgxID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgICAgICBjcHkxID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oY3B4MSwgY3B5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgIGNweCA9IHBhcnNlSW50KG91dGxpbmVbaSsrXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICAgICAgY3B5ID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgICAgICBjcHgxID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgICAgICBjcHkxID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgICAgICBjcHgyID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgICAgICBjcHkyID0gcGFyc2VJbnQob3V0bGluZVtpKytdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgICAgICBwYXRoLmJlemllckN1cnZlVG8oY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBvZmZzZXRYOiBnbHlwaC5oYSAqIHNjYWxlLCBwYXRoIH07XG59XG5leHBvcnQge1xuICBGb250LFxuICBGb250TG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9udExvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/FontLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NuaXBlci1haS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz9kMjgxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxlQUFlLGtEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2REFBMEI7QUFDOUM7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLHNCQUFzQixjQUFjO0FBQ3BDLG9CQUFvQiw2REFBVTtBQUM5QixvQkFBb0IsNkRBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQyxtQkFBbUIsbURBQW1EO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQWU7QUFDekM7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQTtBQUNBLG1DQUFtQyxrREFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQW1CLGlCQUFpQix3REFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFtQjtBQUMxQyx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMENBQU87QUFDekIsa0JBQWtCLDBDQUFPO0FBQ3pCLGtCQUFrQiwwQ0FBTztBQUN6QixxQkFBcUIsMENBQU87QUFDNUIscUJBQXFCLDBDQUFPO0FBQzVCLHFCQUFxQiwwQ0FBTztBQUM1QixzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FBQzdCLHNCQUFzQiwwQ0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NuaXBlci1haS8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qcz9iN2EyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;